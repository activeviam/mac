{
  "style" : { },
  "showTitleBar" : false,
  "body" : {
    "pages" : [ {
      "content" : [ {
        "key" : "1",
        "bookmark" : {
          "name" : "Memory Analysis Cube",
          "type" : "container",
          "value" : {
            "style" : { },
            "showTitleBar" : false,
            "body" : {
              "editingMode" : "view",
              "renderer" : "markdown",
              "content" : "# Memory Analysis Cube\n\nThe Memory Analysis Cube (MAC) is an ActivePivot project that aims to provide\nthe necessary tools to explore and analyze the data consumption from any other\nActivePivot application, starting from ActivePivot 5.8 onwards.\n\n## Bookmarks\n\nA certain number of predefined bookmarks are available. Each offer some insight to\nvarious aspects of the monitored application.\n\n* [Overview](#/dashboard/overview)\n* [Per-field Analysis](#/dashboard/fields)\n* [Vector Block Analysis](#/dashboard/vectors)\n* [Dictionary and Index Analysis](#/dashboard/dictionaries_indexes)\n* [Aggregate Provider Analysis](#/dashboard/aggregate_providers)\n\n> Make sure you are familiar with MAC's data model before interpreting results from\n> the bookmarks.\n>\n> Please refer to the *Data Model* page of this bookmark for information about this.\n\n### Common Pitfalls\n\nThis special bookmark compiles a few common problems regarding memory usage in ActivePivot,\nalong with views that can help quickly spot whether the analyzed application\nsuffers from these problems or not.\n\nThe bookmark can be found [here](#/dashboard/common_pitfalls)."
            },
            "containerKey" : "rich-text-editor"
          },
          "writable" : true
        }
      } ],
      "layout" : {
        "ck" : "1"
      },
      "name" : "Home"
    }, {
      "content" : [ {
        "key" : "1",
        "bookmark" : {
          "name" : "Exporting Data from an ActivePivot Application",
          "type" : "container",
          "value" : {
            "style" : { },
            "showTitleBar" : false,
            "body" : {
              "editingMode" : "view",
              "renderer" : "markdown",
              "content" : "# Exporting Data from an ActivePivot Application\n\nThe exporting of an ActivePivot application is done through an\n`IMemoryAnalysisService`.\n\nThis service can be instantiated\n[programmatically](#export-memory-reports-programmatically), or exposed by\nsetting up a [JMX Bean](#export-memory-reports-through-an-mbean).\n\n## Export Memory Reports Programmatically\n\nThe basic implementation of `IMemoryAnalysisService` is `MemoryAnalysisService`.\nIt can be instantiated through its constructor, passing the Datastore and\nActivePivot Manager we want to export.\n\n```java\nnew MemoryAnalysisService(\n    datastore,\n    manager,\n    datastore.getEpochManager(),\n    exportPath);\n```\n\nAll reports will be exported in a sub-folder inside the specified `exportPath`.\n\nThe `IMemoryAnalysisService` then provides a number of methods for generating\nmemory reports:\n* `exportMostRecentVersion(String)`: exports the application based on the\n  current epoch\n* `exportApplication(String)`: exports all versions of the application\n* `exportBranches(String, Set<String>)`: exports the heads of all specified\n  branches\n* `exportVersions(String, long[])`: exports the application for all specified\n  epoch ids\n\nThe first string argument of these method is the name of the sub-directory the\nreport should be stored in. Each method returns the `Path` in which the report\ncan be found.\n\n## Export Memory Reports through an MBean\n\n### MBean Definition\n\nThe `IMemoryAnalysisService` can be created and exposed through a JMX MBean,\nusing the following snippet:\n```java\n@Bean\npublic JMXEnabler JMXMemoryMonitoringServiceEnabler() {\n    final IDatastore datastore;\n    final IActivePivotManager manager;\n    return new JMXEnabler(\n        new MemoryAnalysisService(\n            datastore,\n            manager,\n            datastore.getEpochManager(),\n            Paths.get(System.getProperty(\"java.io.tmpdir\"))));\n}\n```\n\nIn the above code, we created a new service using the application Datastore and\nActivePivot Manager. We also specified the directory of the export folder as the\nOS temp directory. All generated reports will be created inside that directory\nas sub-folders.\n\nThe implementation `MemoryAnalysisService` is MBean friendly and will\nautomatically name itself as *MemoryAnalysisService*.\n\n### Generating the Report\n\nTo export a new report, connect to your application an MBean\nbrowser such as Java Mission Control. Alternatives are\nJConsole or JVisualVM - which are proprietary software of Oracle - or the\nopen-sourced VisualVM.\n\nIn the MBean folder *com.quartetfs*, the MBean *MemoryAnalysisService* will\nexpose a certain number of exporting operations. Exporting a range allows to\nexport only the memory required for a given epoch or series of epochs. Exporting\nthe whole application helps detecting how much memory is truly retained, often\nby objects leaking memory.\n\n#### Full Export\n\nWhen exporting the whole application, you are asked to provide a name for the\nexport. This name is used to create a sub-folder inside the application export\ndirectory. The result of the operation call tells us exactly where the report is\nlocated.\n\n#### Version Export\n\nDoing an export of the application for a range of epochs is very similar to\ndoing the full application export. In addition to the export folder, the list of\nepochs to export needs to be specified.\n\nThis list is a comma-separated list of ranges. A range can be one of the\nfollowing:\n\n - a single value like `1`, that will export Epoch 1,\n - a range like `1-3`, that will export Epochs 1, 2 and 3\n\nFor example, the epoch list `1,4-6,9` represents Epochs 1, 4, 5, 6 and 9.\n\nTo get a list of the available epochs, various MBeans exist. For example, you\ncan go to the Epoch Manager and look at the epoch statistics.\n"
            },
            "containerKey" : "rich-text-editor"
          },
          "writable" : true
        }
      }, {
        "key" : "2",
        "bookmark" : {
          "name" : "Data Import",
          "type" : "container",
          "value" : {
            "style" : { },
            "showTitleBar" : false,
            "body" : {
              "editingMode" : "view",
              "renderer" : "markdown",
              "content" : "# Importing Statistics into MAC\n\nThe import path of the application can be configured through the\n_application.yml_ configuration file . The `statistic.folder` property defines\nthe folder being watched by the application, the path can either be relative or\nabsolute. It is set to `./statistics` by default.\n\nIt is not required to manually decompress the exported files before using them\nin the application.\n\n## Importing Process\n\n`.json` files present in the configured folder and all its child directories\nwill be read by the application.\n\nImported data will be tagged with the name of the subdirectory it is in through\nthe `[Import info].[Import info]` hierarchy. Files located at the root of\nstatistics folder will be tagged with a generated name following the format\n`autoload-<datetime>`.\n\nFor example, with the following data inside statistics:\n\n```\nstatistics\n |- export-1\n |  |- store_Trade.json.sz\n |  `- store_Risk.json.sz\n `- export-2\n    |- store_Trade.json.sz\n    `- store_Risk.json.sz\n```\n\nMAC will load two batches of data tagged with _export-1_ and _export-2_. The two\nbatches can be selected and compared in the UI using the hierarchy `[Import\ninfo].[Import info]`.\n\n## Automatic loading\n\nMAC is monitoring the statistics directory for any changes. If you add a new\ndirectory or new files in the directory, they will be automatically loaded.\n\nThis allows to load reports in several operations, dynamically add a new report\nwithout restarting the application or update already imported reports.\n"
            },
            "containerKey" : "rich-text-editor"
          },
          "writable" : true
        }
      } ],
      "layout" : {
        "children" : {
          "0" : {
            "ck" : "1",
            "size" : 0.48
          },
          "1" : {
            "ck" : "2",
            "size" : 0.52
          }
        },
        "direction" : "row"
      },
      "name" : "Generating and Importing reports"
    }, {
      "content" : [ {
        "key" : "1",
        "bookmark" : {
          "name" : "Dimensions and Hierarchies",
          "type" : "container",
          "value" : {
            "style" : { },
            "showTitleBar" : false,
            "body" : {
              "editingMode" : "view",
              "renderer" : "markdown",
              "content" : "# Dimensions and Hierarchies\n\nMAC is composed of one cube. Its base store is based on Chunks, which atomically\ncontain all the off-heap data used by ActivePivot.\n\nChunks are attributed to various higher level structures, that are represented\nhierarchies and dimensions of the application. This page lists all of the\nexisting hierarchies in the application.\n\n## Owners\n\nChunks are always held by a higher-level structure, which is called the *owner*\nin MAC.\n\nThe different owners of an ActivePivot application are stores of the datastore\nand the different cubes of the application.\n\n### Owner\n\nThe members of this single-level hierarchy are the different owners of the\nexported application.\n\nFor example, if the exported application has two cubes `Query` and `Data` and\ntwo stores `Trade` and `Product`, the `Owner` hierarchy will have the following\nmembers:\n* `Cube Query`\n* `Cube Data`\n* `Store Trade`\n* `Store Product`\n\nA chunk may be shared by multiple owners. For example, two stores with one\nreferencing the other can share the same dictionary for the fields used by the\nreference. MAC will attribute the dictionary's chunks to both stores.\n\n### Owner Type\n\nThis single-level bucketing hierarchy has two members, `Store` and `Cube`, and\ncan be used to distinguish between both owner types.\n\n## Components\n\nChunks are used by a variety of higher-level structures, such as indexes,\nreferences, dictionaries, etc. This hierarchy associates each chunk with one or\nmore of these *components*:\n\n* `DICTIONARY`\n* `RECORDS`\n* `INDEX`\n* `REFERENCE`\n* `VECTOR_BLOCK`\n* `LEVEL`\n* `POINT_MAPPING`\n* `POINT_INDEX`\n* `BITMAP_MATCHER`\n* `AGGREGATE_STORE` *(for bitmap and leaf providers)*\n\nA chunk may be attributed to several components. If a dictionary is used by an\nindex, its chunks will be attributed to both the `DICTIONARY` and `INDEX`\ncomponents for example.\n\n## Fields\n\nThe Field single-level hierarchy contains:\n* For store chunks: the field(s) the chunk can be attributed to\n* For cube chunks: the measure(s) the chunk can be attributed to\n\nA chunk may be attributed to multiple fields in the case of chunks of an index\nover multiple fields of a store for example.\n\n## Chunks\n\nThis dimension contains various hierarchies related to the monitored chunks.\n\nFor detailed analyses, its hierarchies give access to monitoring data at the\nfinest granularity, the chunks being the grain of MAC's internal base store.\n\n### ChunkId\n\nThe internal ID that identifies the chunk.\n\n### Class\n\nThe java class used by the chunk.\n\nThis can be useful to check whether or not chunk compression is used by looking\nfor classes using some sort of compression on their data.\n\n### DicoID\n\nIf relevant, the ID of the parent dictionary the chunks are attributed to.\n\n### IndexID\n\nIf relevant, the ID of the parent index the chunks are attributed to.\n\n### ReferenceID\n\nIf relevant, the ID of the parent reference the chunks are attributed to.\n\n### ParentID\n\nAn ID internal to MAC that identifies the parent structure owning the chunk (can\nbe a dictionary, an index or a reference).\n\n### Type\n\nThe type of the structure owning the chunk. Can be one of:\n* `DICTIONARY`\n* `RECORDS`\n* `INDEX`\n* `VECTOR_BLOCK`\n* `REFERENCE`\n* `AGGREGATE_STORE`\n* `POINT_INDEX`\n* `POINT_MAPPING`\n\nThis hierarchy categorizes chunks in a way similar to the *Component* hierarchy,\nbut its members designate lower-level structures than the *Component* hierarchy.\nFor example, an `INDEX` **component** may have chunks of **type** `INDEX` and\n`DICTIONARY`.\n\n## Indices\n\nThis dimension contains information about indices. It is only relevant and\ndefined for chunks that can be attributed to an index.\n\n### Index Type\n\nThis single-level hierarchy contains three members for each possible index type:\n* `Key`: index on a store key field\n* `Primary`: primary index of a store\n* `Secondary`: secondary index of a store\n\n### Indexed Fields\n\nThe members of this single-level hierarchy are all the different groups of store\nfields the various indices are defined upon.\n\nWhile related, this hierarchy should not be confused with the `[Fields].[Field]`\nhierarchy, and allows for characterizing all the fields of an index.\n\nFor example, given the two following indices:\n* index 1 on fields `Field A` and `Field B`\n* index 2 on fields `Field A`, `Field B` and `Field C`\n\nIndex 1 will have its chunks attributed to *fields* `[Field A]` and `[Field B]`,\nand to *indexed fields* `[Field A, Field B]`.\n\nIndex 2 will have its chunks attributed to *fields* `[Field A]`, `[Field B]` and\n`[Field C]`, and to *indexed fields* `[Field A, Field B, Field C]`.\n\nA query on the chunks attributed to *fields* `[Field A]` and `[Field B]` will\nyield the chunks of both indices, while a query on *indexed fields* `[Field A,\nField B]` will only yield the chunks of index 1.\n\n## Aggregate Provider\n\nThe hierarchies of these dimensions are relevant for chunks that are attributed\nto a cube owner.\n\n### Provider Category\n\nDistinguishes between full and partial providers. Possible members are:\n* `Full`\n* `Partial`\n* `Unique` *(when the cube uses a single provider)*\n\n### Provider Type\n\nDistinguishes between the underlying aggregate provider type. Possible members\nare:\n* `JIT`\n* `Leaf`\n* `Bitmap`\n\n### Manager\n\nThe name of the manager the chunks are attributed to.\n\n### Provider ID\n\nThe ID of the aggregate provider the chunks are attributed to.\n\n## Partitions\n\nThe store or aggregate provider partition the chunk belongs to, depending on\nwhether the chunk belongs to a cube or a store.\n\n## Versions\n\n### Branch\n\nA single-level slicing hierarchy whose members are the branches of the exported\nchunks. Its default member is the `master` branch.\n\n### Epoch Id\n\nA single-level hierarchy whose members are the epoch ids of the exported chunks.\n\n> **Important:** if an epoch prior to the most recent version is exported using\n> `IMemoryAnalysisService.exportVersions()`, the report will not be a \"snapshot\"\n> of the memory footprint of the application at this epoch.\n>\n> The present chunks are always chunks that are still present at the time of the\n> export either because they are still used by the most recent version or\n> because they were not yet discarded.\n\n### Used By Version\n\nThis single-level hierarchy describes, for each chunk and epoch id whether or\nnot the chunk is \"used\" by the corresponding version i.e. if it has not been\nflagged as deleted in a previous version.\n\n* `TRUE`: the chunk is still used by the expressed epoch\n* `FALSE`: the chunk has been fully marked as deleted in a previous version\n* `UNKNOWN`: the chunk cannot be classified - this can be the case for bitmap\n  aggregate store chunks for example\n\n## Import Info\n\nThis dimension contains metadata about the origin of the imported chunks, since\nmultiple statistics folder can be imported at once in the same MAC session.\n\n### Date\n\nThe date at which the statistics have been imported.\n\n### Import Info\n\nThe *Import Info* hierarchy contains the name of the folder that contained the\nstatistics. If the statistics had no parent folder, the name `autoload-<timestamp>` will be attributed for the *Import Info* of the\nstatistic.\n"
            },
            "containerKey" : "rich-text-editor"
          },
          "writable" : true
        }
      }, {
        "key" : "2",
        "bookmark" : {
          "name" : "Measures",
          "type" : "container",
          "value" : {
            "style" : { },
            "showTitleBar" : false,
            "body" : {
              "editingMode" : "view",
              "renderer" : "markdown",
              "content" : "# Measures\n\n## Application memory footprint\nThese measures come from statistics that were exported using the memory MBean of\nthe application.\n\nSince they are application-wide, they have the same value for all locations.\n\n* `UsedHeapMemory`: the amount of heap memory used by the application\n* `CommittedHeapMemory`: the total size of the JVM heap\n* `UsedDirectMemory`: the amount of off-heap memory used by the application\n* `MaxDirectMemory`: the amount of off-heap memory reserved by the application\n\n## Chunk memory footprint:\n* `DirectMemory.SUM`: the off-heap size of the chunks\n* `DirectMemory.Ratio`: the total ratio of off-heap memory consumed by the chunks\n  relative to the total off-heap memory used by all chunks\n  $$\n  \\relax{DirectMemory.Ratio}\\coloneqq\\frac\\relax{DirectMemory.SUM}\\relax{grandTotal(DirectMemory.SUM)}\n  $$\n* `UsedMemory.Ratio`: the total ratio of off-heap memory consumed by the chunks\n  relative to the total used application committed direct memory\n  $$\n  \\relax{UsedMemory.Ratio}\\coloneqq\\frac\\relax{DirectMemory.SUM}\\relax{UsedDirectMemory}\n  $$\n* `MaxMemory.Ratio`: the total ratio of off-heap memory consumed by the chunks\n  relative to the total application committed direct memory\n  $$\n  \\relax{MaxMemory.Ratio}\\coloneqq\\frac\\relax{DirectMemory.SUM}\\relax{MaxDirectMemory}\n  $$\n* `HeapMemory.SUM`: an estimate of the on-heap size of the chunks\n  > **Warning**: do **NOT** assume total on-heap memory usage by ActivePivot\n  > based on this measure.\n  >\n  > These estimates rely on manual calculations from within the application that\n  > can not precisely capture on-heap memory consumption, and much less its\n  > attribution to higher level structures.\n  >\n  > Please use another tool dedicated to analysis of on-heap memory for Java\n  > applications instead.\n* `CommittedChunkMemory.SUM`: the portion of memory in bytes used to store\n  committed rows in chunks\n  $$\n  \\relax{CommittedChunkMemory.SUM}\\coloneqq\\frac\\relax{CommittedRows.COUNT}\\relax{ChunkSize.SUM}\\times\\relax{DirectMemory.SUM}\n  $$\n\n## Chunk characteristics:\n* `Chunks.COUNT`: the number of contributing chunks\n  > `contributors.COUNT` does not correspond to `Chunks.COUNT`, so prefer using\n  > `Chunks.COUNT`.\n* `ChunkSize.SUM`: a sum aggregation of the chunk sizes\n* `CommittedRows.COUNT`: the number of committed (i.e. used) rows inside the chunks\n* `CommittedRows.Ratio`: the ratio of committed (i.e. used) rows inside the\n  chunks\n  $$\n  \\relax{CommittedRows.Ratio}\\coloneqq\\frac\\relax{CommittedRows.COUNT}\\relax{ChunkSize.SUM}\n  $$\n* `NonWrittenRows.COUNT`: the number of unused rows within the chunks\n* `NonWrittenRows.Ratio`: the ratio of unused rows within the chunks\n  $$\n  \\relax{NonWrittenRows.Ratio}\\coloneqq\\frac\\relax{NonWrittenRows.COUNT}\\relax{ChunkSize.SUM}\n  $$\n* `DeletedRows.COUNT`: the number of freed rows within the chunks\n* `DeletedRows.Ratio`: the ratio of freed rows within the chunks\n  $$\n  \\relax{DeletedRows.Ratio}\\coloneqq\\frac\\relax{DeletedRows.COUNT}\\relax{ChunkSize.SUM}\n  $$\n\n> The following holds true:\n> $$\n> \\relax{CommittedRows.COUNT}\n> + \\relax{NonWrittenRows.COUNT}\n> + \\relax{DeletedRows.COUNT}\n> = \\relax{ChunkSize.SUM}\n> $$\n\n## Miscellaneous\n* `DictionarySize.SUM`: the number of entries in the corresponding dictionary, when\n  relevant\n* `VectorBlock.Length`: the length of the vector block, when relevant\n* `VectorBlock.RefCount`: the number of references to the vector block, when\n  relevant"
            },
            "containerKey" : "rich-text-editor"
          },
          "writable" : true
        }
      }, {
        "key" : "3",
        "bookmark" : {
          "name" : "Many-to-many relationships",
          "type" : "container",
          "value" : {
            "style" : { },
            "showTitleBar" : false,
            "body" : {
              "editingMode" : "view",
              "renderer" : "markdown",
              "content" : "### Aside on many-to-many relationships\n\nChunks have a many-to-many relationships with many of the hierarchies in MAC, meaning that some care needs to be taken when interpreting aggregations.\n\nFor example, the memory consumption of an *owner* will not be equal to the sum of the memory consumption of its *components*, since some chunks can be shared by multiple components.\n\nAnother example would be that if a very large index is shared across multiple stores, all these stores will appear as very large even if there is effectively only one large index that needs consideration.\n"
            },
            "containerKey" : "rich-text-editor"
          },
          "writable" : true
        }
      } ],
      "layout" : {
        "children" : {
          "0" : {
            "ck" : "1"
          },
          "1" : {
            "children" : {
              "0" : {
                "ck" : "2",
                "size" : 0.74
              },
              "1" : {
                "ck" : "3",
                "size" : 0.26
              }
            },
            "direction" : "column"
          }
        },
        "direction" : "row"
      },
      "name" : "Data Model"
    } ]
  },
  "containerKey" : "dashboard"
}
